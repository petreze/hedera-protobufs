/**
 * <h1> Basic Types </h1>
 * Fundamental message types used across transactions and state as field types.
 *
 * <h3> Requirements for Entity ID values </h3>
 * Most entities in the network are identified by a multi-part ID.  These ID values consist of
 * a shard, a realm, and an entity identifier.
 *
 * Shard, Realm, and Entity Number are all whole numbers.
 *
 * A Shard SHALL be globally unique.
 *
 * A Realm MAY be reused between shards, but SHALL be unique within a shard.
 *
 * An Entity Number MAY be reused between shards and realms, but SHALL be unique within a realm.
 *
 * Every object (e.g. account, file, token, etc...) SHALL be scoped to exactly one realm and shard.
 * Thus a File has a FileID, a numeric triplet, such as 0.0.2 for shard 0, realm 0, entity 2.
 *
 * ID values SHOULD use an Entity Number as the third component of the ID.
 * Some, however, MAY use alternative or composite values for the Entity portion of the
 * three part ID.  Any such alternative or composite value MUST be unique within that realm.
 *
 * The entity portion of the ID, regardless of type, MUST be unique within that realm and MAY be
 * globally unique.
 *
 * The triplet of shard.realm.entity MUST be globally unique, even across different ID types.
 *
 * Each realm SHALL maintain a single counter for entity numbers, so if there is an ID
 * with value 0.1.2, then there MUST NOT be another ID with value 0.1.2 for any other object.
 *
 * <h3> Keywords </h3>
 * The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
 * "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
 * document are to be interpreted as described in [RFC2119](https://www.ietf.org/rfc/rfc2119).
 */
syntax = "proto3";

package proto;

/*
 *
 * Hedera Network Services Protobuf
 *
 * Copyright (C) 2018 - 2022 Hedera Hashgraph, LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

import "timestamp.proto";
import "google/protobuf/wrappers.proto";

option java_package = "com.hederahashgraph.api.proto.java";
// <<<pbj.java_package = "com.hedera.hapi.node.base">>> This comment is special code for setting PBJ Compiler java package
option java_multiple_files = true;

/**
 * A shard number.  A shard is a partition of nodes running the network that processes transactions
 * separately from other shards.  Each shard is effectively an independent instance of the overall
 * network that shares the same virtual distributed ledger, and may gossip cross-shard transactions
 * with other shards to maintain overall correct processing of the ledger.
 */
message ShardID {
    /**
     * A whole number shard number
     */
    int64 shardNum = 1;
}

/**
 * The ID for a realm. Within a given shard, every realm has a unique ID. Each account, file, and
 * contract instance belongs to exactly one realm.
 *
 * Everything is partitioned into realms so that each Solidity smart contract can  access everything
 * in just a single realm, locking all those entities while it's  running, but other smart contracts
 * could potentially run in other realms in  parallel. So realms allow Solidity to be parallelized
 * somewhat, even though the  language itself assumes everything is serial.
 */
message RealmID {
    /**
     * A whole number shard number
     */
    int64 shardNum = 1;

    /**
     * A whole number realm number
     */
    int64 realmNum = 2;
}

/**
 * Unique identifier for a token
 */
message TokenID {
    /**
     * A whole number shard number
     */
    int64 shardNum = 1;

    /**
     * A whole number realm number
     */
    int64 realmNum = 2;

    /**
     * A whole number token number
     */
    int64 tokenNum = 3;
}

/**
 * The ID for a cryptocurrency account.
 *
 * An account ID is of the form `shard.realm.[number|alias]`,
 * The <strong>ID</strong> will generally use the alias value when transferring HBAR to a public key before the
 * account for that key is created, when only the alias value is known, or in some smart contracts that use the
 * EVM address style alias to reference Accounts.
 *
 * When the account entry is completed, the alias SHALL be stored separately in the Account record, and the ID in the Account SHALL use the `accountNum` form.
 * <div style="display: none">Note: The following is included here because it breaks tables if attached to the field below</div>
 * ---
 * There is considerable complexity with `alias` (aka `evm_address`) for Accounts.
 * Much of this comes from the existence of a "hidden" alias for almost all accounts, and the
 * reuse of the alias field for both EVM reference and "automatic" account creation.
 * <p>
 * For the purposes of this specification, we will use the following terms for clarity.
 *   - `key_alias` is the account public key as a protobuf serialized message and used for
 *     auto-creation and subsequent lookup.  This is only valid if the account key is a
 *     single `primitive` key, either ED25519 or ECDSA_SECP256K1.
 *   - `evm_address` exists for every account and is one of
 *      - `contract_address`, which is the 20 byte EVM contract address per EIP-1014
 *      - `evm_key_address`, which is the keccak-256 hash of a ECDSA_SECP256K1 `primitive` key.
 *         - This is for accounts lazy-created from EVM public keys, when the corresponding
 *           ECDSA_SECP256K1 public key is presented in a transaction signed by the
 *           private key for that public key, the account is created that key assigned, and
 *           the protobuf-serialized form is set as the account alias.
 *      - `long_zero`, is a synthetic 20 byte address inferred for "normally" created
 *        accounts. It is constructed from the "standard" AccountID as follows.
 *         - 4 byte big-endian shard number
 *         - 8 byte big-endian realm number
 *         - 8 byte big-endian entity number
 * <p>
 * The `alias` field in the `Account` message SHALL contain one of four values for any given account.
 *   - The `key_alias`, if the account was created by transferring HBAR to the account
 *     referenced by `key_alias`.
 *   - The `evm_key_address` if the account was created from an EVM public key
 *   - The `contract_address` if the account belongs to an EVM contract
 *   - Not-Set/null/Bytes.EMPTY (collectively `null`) if the account was created normally
 * If the `alias` field of an `Account` is any form of `null`, then the account MAY be
 * referenced by `alias` in an `AccountID` by using the `long_zero` address for the account.
 * This "hidden default" alias SHALL NOT be stored, but is synthesized by the node software as
 * needed, and may be synthesized by an EVM contract or client software as well.
 * <p>
 * >> Note<br/>
 * >> The use and meaning of `alias` is expected to change significantly as a result of HIP-631.
 * <p>
 * An `AccountID` in a transaction MAY reference an `Account` with `shard.realm.alias`.
 * If the account `alias` field is set for an Account, that value SHALL be the account alias.
 * If the account `alias` field is not set for an Account, the `long_zero` alias
 * SHALL be the account alias.
 */
message AccountID {
    /**
     * A whole number shard number
     */
    int64 shardNum = 1;

    /**
     * A whole number realm number
     */
    int64 realmNum = 2;

    /**
     * The account number, unique within its realm, an alias public key, or an EVM address.
     * For any AccountID fields in the query response, transaction records, transaction receipts,
     * or block stream `accountNum` SHALL be used.
     */
    oneof account {
        /**
         * A whole number account number, unique within its realm and shard
         */
        int64 accountNum = 3;

    /**
     * Alias is a value used in some contexts to reference an account when account number is not
     * available.
     */
        bytes alias = 4;
    }
}

/**
 * Identifier for a unique token (or "NFT"), used by both contract and token services.
 */
message NftID {
    /**
     * The token that represents the collection containing this NFT.
     */
    TokenID token_ID = 1;

    /**
     * The serial number of this NFT, unique within its token type.
     */
    int64 serial_number = 2;
}

/**
 * Identifier for a File within the network
 */
message FileID {
    /**
     * A whole number shard number
     */
    int64 shardNum = 1;

    /**
     * A whole number realm number
     */
    int64 realmNum = 2;

    /**
     * A whole number File number, unique within its realm and shard
     */
    int64 fileNum = 3;
}

/**
 * The identifier for a smart contract within the network
 */
message ContractID {
    /**
     * A whole number shard number
     */
    int64 shardNum = 1;

    /**
     * A whole number realm number
     */
    int64 realmNum = 2;

    oneof contract {
        /**
        * A whole number contract number, unique within its realm and shard
        */
        int64 contractNum = 3;

        /**
        * A 20-byte EVM address of the contract to call.
        *
        * Every contract has an EVM address determined by its `shard.realm.num` id.
        * This address is as follows:
        * <ul>
        *     <li>4 byte big-endian shard number</li>
        *     <li>8 byte big-endian realm number</li>
        *     <li>8 byte big-endian contract number</li>
        * </ul>
        * This address is not stored in state, but is computed when needed.
        *
        * Contracts created via CREATE2 have an <b>additional, primary address</b> that is
        * derived from the <a href="https://eips.ethereum.org/EIPS/eip-1014">EIP-1014</a>
        * specification, and does not have a simple relation to a `shard.realm.num` id.
        *
        * (Note that CREATE2 contracts MAY also be referenced by the three-part EVM address described above.)
        */
        bytes evm_address = 4;
    }
}

/**
 * The ID for a transaction. This is used for retrieving receipts and records for a transaction, for
 * appending to a file after creating it, for instantiating a smart contract with bytecode in
 * a file just created, and internally by the network for detecting when duplicate transactions are
 * submitted.
 * A user might get a transaction processed faster by submitting it to N nodes, each with
 * a different node account, but all with the same TransactionID. Then, the transaction will take
 * effect when the first of all those nodes submits the transaction and it reaches consensus. The
 * other transactions will not take effect (and SHALL result in a
 * [DUPLICATE_TRANSACTION](ResponseCodeEnum#DUPLICATE_TRANSACTION) response).
 * This could reduce the latency for a transaction, and increase reliability in the event of
 * networking or other errors.  The full transaction fee is charged for each transaction,
 * however, so the total fee is N times as much if the transaction is sent to N nodes.
 *
 * Additional items applicable to Scheduled Transactions:
 *  - The ID of a Scheduled Transaction, once executed, has transactionValidStart and accountID
 *    inherited from the ScheduleCreate transaction that created it.
 *  - The scheduled property is true for Scheduled Transactions.
 */
message TransactionID {
    /**
     * The transaction is invalid if consensusTimestamp < transactionID.transactionStartValid
     */
    Timestamp transactionValidStart = 1;

    /**
     * The Account ID that will pay transaction fees for this transaction.
     */
    AccountID accountID = 2;

    /**
     * Whether the transaction represents the execution of a Schedule after all necessary signatures
     * are gathered.
     */
    bool scheduled = 3;

    /**
     * The identifier for an internal transaction that was spawned as part
     * of handling a user transaction. (These internal transactions share the
     * transactionValidStart and accountID of the user transaction, so a
     * nonce is necessary to give them a unique TransactionID.)
     * <p>
     * An example is when a "parent" ContractCreate or ContractCall transaction
     * calls one or more HTS precompiled contracts; each of the "child"
     * transactions spawned for a precompile has a transaction id with a different nonce.
     * <p>
     * This value SHALL be unset for user-submitted transactions.
     */
    int32 nonce = 4;
}

/**
 * An account, and the amount that it sends or receives during a token transfer.
 * <p>
 * This message is only relevant to fungible token transfers.  Non-fungible (NFT) token
 * transfers SHALL use the NftTransfer message.
 */
message AccountAmount {
    /**
     * The Account ID that will send or receive token(s).
     */
    AccountID accountID = 1;

    /**
     * The amount to send (negative) or receive (positive).<br/>
     * This amount is denominated in the smallest unit of the relevant token.<br/>
     * For HBAR this is tinybar (10<sup>-8</sup> HBAR).<br/>
     * For other fungible tokens this depends on the value of `decimals` for that token.
     */
    sint64 amount = 2;

    /**
     * If true then the transfer is expected to be an approved allowance and the
     * accountID SHALL be the owner that previously approved the allowance.<br/>
     * The default is false (unset).
     */
    bool is_approval = 3;
}

/**
 * A list of accounts and fungible token amounts to transfer.<br/>
 * Each `AccountAmount` specifies the account and the amount to send(negative) or receive(positive).<br/>
 * Each `TransferList` SHALL be contained in another message that details which `Token` is transferred.
 */
message TransferList {
    /**
     * Multiple list of AccountAmount pairs, each of which has an account and
     * an amount to transfer into it (positive) or out of it (negative)
     */
    repeated AccountAmount accountAmounts = 1;
}

/**
 * A sender account, a receiver account, and the serial number of an NFT to transfer.
 * <p>
 * Each `NftTransfer` SHALL be contained in another message that details which `Token` type applies
 * to this NFT transfer.
 */
message NftTransfer {
    /**
     * The accountID of the sender
     */
    AccountID senderAccountID = 1;

    /**
     * The accountID of the receiver
     */
    AccountID receiverAccountID = 2;

    /**
     * The serial number of the NFT
     */
    int64 serialNumber = 3;

    /**
     * If true then the transfer is expected to be an approved allowance and the
     * senderAccountID SHALL be the owner that approved the allowance. The default is false (unset).
     */
    bool is_approval = 4;
}

/**
 * A list of transfers for a particular token type.
 * <p>
 * A `TokenTransferlist` applies to a single token type, but may contain many individual transfers.
 * Each transfer of a fungible token specifies an `accountID` and `amount`
 * A list of token IDs and amounts representing the transferred out (negative) or in (positive)
 * amounts, presented in the lowest denomination of the token for fungible tokens, or as a serial
 * number for non-fungible tokens.
 */
message TokenTransferList {
    /**
     * The ID of the token
     */
    TokenID token = 1;

    /**
     * Applicable to tokens of type FUNGIBLE_COMMON. Multiple list of AccountAmounts, each of which
     * has an account and amount
     */
    repeated AccountAmount transfers = 2;

    /**
     * Applicable to tokens of type NON_FUNGIBLE_UNIQUE. Multiple list of NftTransfers, each of
     * which has a sender and receiver account, including the serial number of the NFT
     */
    repeated NftTransfer nftTransfers = 3;

    /**
     * The number of decimals a fungible token type is _expected_ to have. The transfer SHALL
     * fail with <a href="ResponseCodeEnum#UNEXPECTED_TOKEN_DECIMALS">UNEXPECTED_TOKEN_DECIMALS</a>
     * if this is set and the actual decimals specified for the `Token` differ from this value.
     */
    google.protobuf.UInt32Value expected_decimals = 4;
}

/**
 * A rational number.
 * A common use is to set the amount of a value transfer to collect as a custom fee.
 * It is RECOMMENDED that both numerator and denominator be no larger than necessary to express
 * the required fraction.  A very large numerator, in particular, may not be reliable.
 */
message Fraction {
    /**
     * The fractional number's numerator
     */
    int64 numerator = 1;

    /**
     * The fractional number's denominator; a zero value SHALL result in FRACTION_DIVIDES_BY_ZERO.
     */
    int64 denominator = 2;
}

/**
 * Unique identifier for a topic.
 * Topics are part of the consensus service, messages are published to a topic.
 */
message TopicID {
    /**
     * A whole number shard
     */
    int64 shardNum = 1;

    /**
     * A whole number realm
     */
    int64 realmNum = 2;

    /**
     * A whole number topic, unique within its realm and shard
     */
    int64 topicNum = 3;
}

/**
 * Unique identifier for a Schedule
 */
message ScheduleID {
    /**
     * A whole number shard
     */
    int64 shardNum = 1;

    /**
     * A whole number realm
     */
    int64 realmNum = 2;

    /**
     * A whole number schedule, unique within its realm and shard
     */
    int64 scheduleNum = 3;
}

/**
 * Possible Token Types (IWA Compatibility).
 * Apart from fungible and non-fungible, Tokens can have either a common or unique representation.
 * This distinction might seem subtle, but it is important when considering how tokens can be traced
 * and if they can have isolated and unique properties.
 * <p>
 * A few examples (these may not match enumerations below) using IWA taxonomy.
 * <dl>
 *   <dt>fungible, whole, intrinsic, unique</dt><dd>Physical currency</dd>
 *   <dt>fungible, fractional, intrinsic, common</dt><dd>bank balance currency</dd>
 *   <dt>non-fungible, fractional, reference, unique</dt><dd>"mutual" collectible/art/property ownership</dd>
 *   <dt>non-fungible, whole, intrinsic, unique</dt><dd>Physical work of fine art</dd>
 *   <dt>non-fungible, whole, reference, unique</dt><dd>Registered property title</dd>
 * </dl>
 */
enum TokenType {
    /**
     * Interchangeable with one another, where any quantity of them has the same value as
     * another equal quantity if they are in the same class.  Share a single set of properties, not
     * distinct from one another. Represented as a balance or quantity associated to a given account.
     * <p>
     * IWA taxonomy _fungible, fractional, intrinsic, common_
     */
    FUNGIBLE_COMMON = 0;

    /**
     * Unique, not interchangeable with other tokens of the same type.  Each token carries a
     * serial number which is unique for that token, these tokens may have a different trade value
     * for each individual token.  The tokens are individually accounted and often carry
     * additional unique properties.
     * <p>
     * IWA taxonomy _non-fungible, whole, reference, unique_
     */
    NON_FUNGIBLE_UNIQUE = 1;
}

/**
 * A transaction sub type.<p>
 * This enumeration enables a set of transaction base fees to be broadly defined for a HAPI
 * operation while taking some specifics of the operation into account.
 * <p>
 * For example, the resource cost for a TokenMint operation is different between minting fungible
 * and non-fungible tokens. This enum is used to "mark" a cost as applying to one or the other.<br/>
 * Similarly, the resource cost for a basic TokenCreate without a custom fee schedule may yield a
 * base fee of $1. The resource cost for a TokenCreate _with_ a custom fee schedule is different
 * and may yield a base fee of $2 or more.
 */
enum SubType {
    /**
     * The resource cost for the transaction type has no additional attributes
     */
    DEFAULT = 0;

    /**
     * The resource cost for the transaction type includes an operation on a fungible common token
     */
    TOKEN_FUNGIBLE_COMMON = 1;

    /**
     * The resource cost for the transaction type includes an operation on a non-fungible unique token
     */
    TOKEN_NON_FUNGIBLE_UNIQUE = 2;

    /**
     * The resource cost for the transaction type includes an operation on a fungible common
     * token with a custom fee schedule
     */
    TOKEN_FUNGIBLE_COMMON_WITH_CUSTOM_FEES = 3;

    /**
     * The resource cost for the transaction type includes an operation on a non-fungible unique
     * token with a custom fee schedule
     */
    TOKEN_NON_FUNGIBLE_UNIQUE_WITH_CUSTOM_FEES = 4;

    /**
     * The resource cost for the transaction type includes a ScheduleCreate containing a ContractCall.
     */
    SCHEDULE_CREATE_CONTRACT_CALL = 5;
}

/**
 * Possible Token Supply Types (IWA Compatibility).
 * Indicates the limit of tokens that can exist during the lifetime of a token definition.
 */
enum TokenSupplyType {
    /**
     * Indicates that tokens of that type have an upper bound of Long.MAX_VALUE.
     * This is accounted in the smallest units of the token (i.e. 10<sup>-`decimals`</sup> whole tokens)
     */
    INFINITE = 0;

    /**
     * Indicates that tokens of that type have an upper bound of `maxSupply`.
     * The maximum supply SHALL be provided on token creation, but MAY be changed thereafter if
     * the token has an `admin_key` set.
     */
    FINITE = 1;
}

/**
 * Possible Freeze statuses returned on TokenGetInfoQuery or CryptoGetInfoResponse in
 * TokenRelationship
 */
enum TokenFreezeStatus {
    /**
     * The token does not support freeze or cannot be frozen for the referenced account.
     */
    FreezeNotApplicable = 0;

    /**
     * The token is currently frozen for the referenced account.
     */
    Frozen = 1;

    /**
     * The token is not currently frozen for the referenced account.
     */
    Unfrozen = 2;
}

/**
 * Possible KYC status values returned on TokenGetInfoQuery or CryptoGetInfoResponse in TokenRelationship
 */
enum TokenKycStatus {
    /**
     * The token does not support KYC or cannot grant KYC for the referenced account.
     */
    KycNotApplicable = 0;

    /**
     * The referenced account is currently granted KYC status for the referenced token.
     */
    Granted = 1;

    /**
     * The referenced account is not currently granted KYC status for the referenced token.
     */
    Revoked = 2;
}

/**
 * Possible Pause status values returned on TokenGetInfoQuery
 */
enum TokenPauseStatus {
    /**
     * The token does not support pause or cannot be paused.
     */
    PauseNotApplicable = 0;

    /**
     * The token is currently paused.
     */
    Paused = 1;

    /**
     * The token is not currently paused.
     */
    Unpaused = 2;
}

/**
 * A Key can be a public key from either the Ed25519 or ECDSA(secp256k1) signature schemes, where
 * in the ECDSA(secp256k1) case we require the 33-byte compressed form of the public key. We call
 * these public keys <b>primitive keys</b>.
 *
 * If an account has primitive key associated to it, then the corresponding private key must sign
 * any transaction to transfer cryptocurrency out of it.
 *
 * A Key can also be the ID of a smart contract instance, which is then authorized to perform any
 * precompiled contract action that requires this key to sign.
 *
 * Note that when a Key is a smart contract ID, it <i>doesn't</i> mean the contract with that ID
 * will actually create a cryptographic signature. It only means that when the contract calls a
 * precompiled contract, the resulting "child transaction" will be authorized to perform any action
 * controlled by the Key.
 *
 * A Key can be a "threshold key", which means a list of M keys, any N of which must sign in order
 * for the threshold signature to be considered valid. The keys within a threshold signature may
 * themselves be threshold signatures, to allow complex signature requirements.
 *
 * A Key can be a "key list" where all keys in the list must sign unless specified otherwise in the
 * documentation for a specific transaction type (e.g.  FileDeleteTransactionBody).  Their use is
 * dependent on context. For example, a Hedera file is created with a list of keys, where all of
 * them must sign a transaction to create or modify the file, but only one of them is needed to sign
 * a transaction to delete the file. So it's a single list that sometimes acts as a 1-of-M threshold
 * key, and sometimes acts as an M-of-M threshold key.  A key list is always an M-of-M, unless
 * specified otherwise in documentation. A key list can have nested key lists or threshold keys.
 * Nested key lists are always M-of-M. A key list can have repeated primitive public keys, but all
 * repeated keys are only required to sign once.
 *
 * A Key can contain a ThresholdKey or KeyList, which in turn contain a Key, so this mutual
 * recursion would allow nesting arbitrarily deep. A ThresholdKey which contains a list of primitive
 * keys has 3 levels: ThresholdKey -> KeyList -> Key. A KeyList which contains several primitive
 * keys has 2 levels: KeyList -> Key. A Key with 2 levels of nested ThresholdKeys has 7 levels:
 * Key -> ThresholdKey -> KeyList -> Key -> ThresholdKey -> KeyList -> Key.
 *
 * Each Key should not have more than 46 levels, which implies 15 levels of nested ThresholdKeys.
 */
message Key {
    oneof key {
        /**
         * smart contract instance that is authorized as if it had signed with a key
         */
        ContractID contractID = 1;

        /**
         * Ed25519 public key bytes
         */
        bytes ed25519 = 2;

        /**
         * (NOT SUPPORTED) RSA-3072 public key bytes
         */
        bytes RSA_3072 = 3;

        /**
         * (NOT SUPPORTED) ECDSA with the p-384 curve public key bytes
         */
        bytes ECDSA_384 = 4;

        /**
         * a threshold N followed by a list of M keys, any N of which are required to form a valid
         * signature
         */
        ThresholdKey thresholdKey = 5;

        /**
         * A list of Keys of the Key type.
         */
        KeyList keyList = 6;

        /**
         * Compressed ECDSA(secp256k1) public key bytes
         */
        bytes ECDSA_secp256k1 = 7;

        /**
         * A smart contract that, if the recipient of the active message frame, should be treated
         * as having signed. (Note this does not mean the <i>code being executed in the frame</i>
         * will belong to the given contract, since it could be running another contract's code via
         * `delegatecall`. So setting this key is a more permissive version of setting the
         * contractID key, which also requires the code in the active message frame belong to the
         * the contract with the given id.)
         */
        ContractID delegatable_contract_id = 8;
    }
}

/**
 * A set of public keys that are used together to form a threshold signature.  If the threshold is N
 * and there are M keys, then this is an N of M threshold signature. If an account is associated
 * with ThresholdKeys, then a transaction to move cryptocurrency out of it must be signed by a list
 * of M signatures, where at most M-N of them are blank, and the other at least N of them are valid
 * signatures corresponding to at least N of the public keys listed here.
 */
message ThresholdKey {
    /**
     * A valid signature set must have at least this many signatures
     */
    uint32 threshold = 1;

    /**
     * List of all the keys that can sign
     */
    KeyList keys = 2;
}

/**
 * A list of keys that requires all keys (M-of-M) to sign unless otherwise specified in
 * documentation. A KeyList may contain repeated keys, but all repeated keys are only required to
 * sign once.
 */
message KeyList {
    /**
     * A list of keys.  All values in this list SHALL be non-null.
     * <p>
     * An empty key list is the "standard" mechanism to represent an unassigned key.  For example,
     * if the `admin_key` of an account is set to the empty key list, then that account has no
     * admin key, and functionality that requires an admin key to sign the transaction is disabled.
     */
    repeated Key keys = 1;
}

/**
 * This message is <b>DEPRECATED</b> and <b>UNUSABLE</b> with network nodes. It is retained
 * here only for historical reasons.
 *
 * Please use the SignaturePair and SignatureMap messages.
 */
message Signature {
    option deprecated = true;

    oneof signature {
        /**
         * smart contract virtual signature (always length zero)
         */
        bytes contract = 1;

        /**
         * ed25519 signature bytes
         */
        bytes ed25519 = 2;

        /**
         * RSA-3072 signature bytes
         */
        bytes RSA_3072 = 3;

        /**
         * ECDSA p-384 signature bytes
         */
        bytes ECDSA_384 = 4;

        /**
         * A list of signatures for a single N-of-M threshold Key. This must be a list of exactly M
         * signatures, at least N of which are non-null.
         */
        ThresholdSignature thresholdSignature = 5;

        /**
         * A list of M signatures, each corresponding to a Key in a KeyList of the same length.
         */
        SignatureList signatureList = 6;
    }
}

/**
 * This message is <b>DEPRECATED</b> and <b>UNUSABLE</b> with network nodes. It is retained
 * here only for historical reasons.
 *
 * Please use the SignaturePair and SignatureMap messages.
 */
message ThresholdSignature {
    option deprecated = true;

    /**
     * for an N-of-M threshold key, this is a list of M signatures, at least N of which must be
     * non-null
     */
    SignatureList sigs = 2;
}

/**
 * This message is <b>DEPRECATED</b> and <b>UNUSABLE</b> with network nodes. It is retained
 * here only for historical reasons.
 * <p>
 * Client software MUST NOT include this message in any request. <br/>
 * Compliant nodes SHALL NOT accept any request containing this message.
 *
 * Please use the SignaturePair and SignatureMap messages.
 */
message SignatureList {
    option deprecated = true;

    /**
     * each signature corresponds to a Key in the KeyList
     */
    repeated Signature sigs = 2;
}

/**
 * A public key and signature pair.
 * Only Ed25519 and ECDSA(secp256k1) keys and hence signatures are currently supported.
 */
message SignaturePair {
    /**
     * Prefix bytes of the public key.
     * <p>
     * The client may use any number of bytes from zero to the whole length of the public key for
     * pubKeyPrefix. If zero bytes are used, then it MUST be true that only one cryptographic key is
     * required to sign the associated transaction.
     * If the `pubKeyPrefix` is 0 bytes and more than a single cryptographic key is required to sign
     * the transaction, the request SHALL resolve to `INVALID_SIGNATURE`.
     * <p>
     * <h3>IMPORTANT</h3>
     * <p>
     * In the special case that a signature is provided to authorize a precompiled contract,
     * the `pubKeyPrefix` MUST contain the _entire public key_.<br/>
     * That is, if the key is an ED25519 key, the `pubKeyPrefix` MUST be 32 bytes long
     * and contain the full public key bytes.<br/>
     * If the key is an ECDSA(secp256k1) key, the `pubKeyPrefix` MUST be 33 bytes long
     * and contain the full _compressed_ form of the public key.
     */
    bytes pubKeyPrefix = 1;

    oneof signature {
        /**
         * A smart contract virtual signature.<br/>
         * This value MUST be length zero, if set.
         */
        bytes contract = 2;

        /**
         * An ED25519 signature.
         */
        bytes ed25519 = 3;

        /**
         * RSA-3072 signature.<br/>
         * This option is not currently supported.
         */
        bytes RSA_3072 = 4;

        /**
         * ECDSA p-384 signature.<br/>
         * This option is not currently supported.
         */
        bytes ECDSA_384 = 5;

        /**
         * An ECDSA(secp256k1) signature.
         */
        bytes ECDSA_secp256k1 = 6;
    }
}

/**
 * A set of signatures corresponding to every unique public key used to sign a given transaction. If
 * one public key matches more than one prefix on the signature map, the transaction containing
 * the map SHALL fail immediately with the response code `KEY_PREFIX_MISMATCH`.
 */
message SignatureMap {
    /**
     * Each signature pair corresponds to a unique cryptographic key required to sign the transaction.
     */
    repeated SignaturePair sigPair = 1;
}

/**
 * The transactions and queries supported by Hedera Hashgraph.
 */
enum HederaFunctionality {
    /**
     * Unused - The first value is unused because this first element is ignored and not parsed
     * (0 is ignored by parser) within the intake logic.
     */
    NONE = 0;

    /**
     * Transfer tokens among accounts.
     */
    CryptoTransfer = 1;

    /**
     * Update an account.
     */
    CryptoUpdate = 2;

    /**
     * Delete an account.
     */
    CryptoDelete = 3;

    /**
     * Add a livehash to an account
     */
    CryptoAddLiveHash = 4;

    /**
     * Delete a livehash from an account
     */
    CryptoDeleteLiveHash = 5;

    /**
     * Execute a smart contract call.
     */
    ContractCall = 6;

    /**
     * Create a smart contract.
     */
    ContractCreate = 7;

    /**
     * Update a smart contract.
     */
    ContractUpdate = 8;

    /**
     * Create a "file" stored in the ledger.
     */
    FileCreate = 9;

    /**
     * Append data to a "file" stored in the ledger.
     */
    FileAppend = 10;

    /**
     * Update a "file" stored in the ledger.
     */
    FileUpdate = 11;

    /**
     * Delete a "file" stored in the ledger.
     */
    FileDelete = 12;

    /**
     * Get the balance for an account.
     */
    CryptoGetAccountBalance = 13;

    /**
     * Get a full account record.
     */
    CryptoGetAccountRecords = 14;

    /**
     * Get information about a token.
     */
    CryptoGetInfo = 15;

    /**
     * Execute a local smart contract call (used by contracts to call other contracts).
     */
    ContractCallLocal = 16;

    /**
     * Get information about a smart contract.
     */
    ContractGetInfo = 17;

    /**
     * Get the compiled bytecode that implements a smart contract.
     */
    ContractGetBytecode = 18;

    /**
     * Get a smart contract record by reference to the solidity ID.
     */
    GetBySolidityID = 19;

    /**
     * Get a smart contract by reference to the contract key.
     */
    GetByKey = 20;

    /**
     * Get the live hash for an account
     */
    CryptoGetLiveHash = 21;

    /**
     * Get the accounts proxy staking to a given account.
     */
    CryptoGetStakers = 22;

    /**
     * Get the contents of a "file" stored in the ledger.
     */
    FileGetContents = 23;

    /**
     * Get the metadata for a "file" stored in the ledger.
     */
    FileGetInfo = 24;

    /**
     * Get transaction record(s) for a specified transaction ID.
     */
    TransactionGetRecord = 25;

    /**
     * Get all transaction records for a specified contract ID in the past 24 hours.
     * @deprecated since version 0.9.0
     */
    ContractGetRecords = 26;

    /**
     * Create a new account
     */
    CryptoCreate = 27;

    /**
     * Delete a "system" "file" stored in the ledger.
     * "System" files are files with special purpose and ID values within a specific range.
     * These files require additional controls and can only be deleted when authorized by
     * accounts with elevated privilege.
     */
    SystemDelete = 28;

    /**
     * Undo the delete of a "system" "file" stored in the ledger.
     * "System" files are files with special purpose and ID values within a specific range.
     * These files require additional controls and can only be deleted when authorized by
     * accounts with elevated privilege. This operation allows such files to be restored,
     * within a reasonable timeframe, if deleted improperly.
     */
    SystemUndelete = 29;

    /**
     * Delete a smart contract
     */
    ContractDelete = 30;

    /**
     * Stop all processing and "freeze" the entire network.
     * This is generally sent immediately prior to upgrading the network.
     * After processing this transactions all nodes enter a quiescent state.
     */
    Freeze = 31;

    /**
     * Create a Transaction Record.
     * This appears to be purely internal and unused.
     */
    CreateTransactionRecord = 32;

    /**
     * Auto-renew an account.
     * This is used for internal fee calculations.
     */
    CryptoAccountAutoRenew = 33;

    /**
     * Auto-renew a smart contract.
     * This is used for internal fee calculations.
     */
    ContractAutoRenew = 34;

    /**
     * Get version information for the ledger.
     * This returns a the version of the software currently running the network for both
     * the protocol buffers and the network services (node).
     */
    GetVersionInfo = 35;

    /**
     * Get a receipt for a specified transaction ID.
     */
    TransactionGetReceipt = 36;

    /**
     * Create a topic for the Hedera Consensus Service (HCS).
     */
    ConsensusCreateTopic = 50;

    /**
     * Update an HCS topic.
     */
    ConsensusUpdateTopic = 51;

    /**
     * Delete an HCS topic.
     */
    ConsensusDeleteTopic = 52;

    /**
     * Get metadata (information) for an HCS topic.
     */
    ConsensusGetTopicInfo = 53;

    /**
     * Publish a message to an HCS topic.
     */
    ConsensusSubmitMessage = 54;

    /**
     * Submit a transaction, bypassing intake checking.
     * Only enabled in local-mode.
     */
    UncheckedSubmit = 55;

    /**
     * Create a token for the Hedera Token Service (HTS).
     */
    TokenCreate = 56;

    /**
     * Get metadata (information) for an HTS token.
     */
    TokenGetInfo = 58;

    /**
     * Freeze a specific account with respect to a specific HTS token.
     * Once this transaction completes that account cannot send or receive the specified token.
     */
    TokenFreezeAccount = 59;

    /**
     * Remove a "freeze" from an account with respect to a specific HTS token.
     */
    TokenUnfreezeAccount = 60;

    /**
     * Grant KYC status to an account for a specific HTS token.
     */
    TokenGrantKycToAccount = 61;

    /**
     * Revoke KYC status from an account for a specific HTS token.
     */
    TokenRevokeKycFromAccount = 62;

    /**
     * Delete a specific HTS token.
     */
    TokenDelete = 63;

    /**
     * Update a specific HTS token.
     */
    TokenUpdate = 64;

    /**
     * Mint HTS token amounts to the treasury account for that token.
     */
    TokenMint = 65;

    /**
     * Burn HTS token amounts from the treasury account for that token.
     */
    TokenBurn = 66;

    /**
     * Wipe all amounts for a specific HTS token from a specified account.
     */
    TokenAccountWipe = 67;

    /**
     * Associate a specific HTS token to an account.
     */
    TokenAssociateToAccount = 68;

    /**
     * Dissociate a specific HTS token from an account.
     */
    TokenDissociateFromAccount = 69;

    /**
     * Create a scheduled transaction
     */
    ScheduleCreate = 70;

    /**
     * Delete a scheduled transaction
     */
    ScheduleDelete = 71;

    /**
     * Sign a scheduled transaction
     */
    ScheduleSign = 72;

    /**
     * Get metadata (information) for a scheduled transaction
     */
    ScheduleGetInfo = 73;

    /**
     * Get NFT metadata (information) for a range of NFTs associated to a specific non-fungible
     * HTS token and owned by a specific account.
     */
    TokenGetAccountNftInfos = 74;

    /**
     * Get metadata (information) for a specific NFT identified by token and serial number.
     */
    TokenGetNftInfo = 75;

    /**
     * Get NFT metadata (information) for a range of NFTs associated to a specific non-fungible
     * HTS token.
     */
    TokenGetNftInfos = 76;

    /**
     * Update a token's custom fee schedule.
     * If a transaction of this type is not signed by the token `fee_schedule_key` it SHALL fail
     * with INVALID_SIGNATURE, or TOKEN_HAS_NO_FEE_SCHEDULE_KEY if there is no `fee_schedule_key`
     * set.
     */
    TokenFeeScheduleUpdate = 77;

    /**
     * Get execution time(s) for one or more "recent" TransactionIDs.
     */
    NetworkGetExecutionTime = 78;

    /**
     * Pause a specific HTS token
     */
    TokenPause = 79;

    /**
     * Unpause a paused HTS token.
     */
    TokenUnpause = 80;

    /**
     * Approve an allowance for a spender relative to the owner account, which MUST sign the
     * transaction.
     */
    CryptoApproveAllowance = 81;

    /**
     * Delete (unapprove) an allowance previously approved for the owner account.
     */
    CryptoDeleteAllowance = 82;

    /**
     * Get all the information about an account, including balance and allowances.
     * This does not get a list of account records.
     */
    GetAccountDetails = 83;

    /**
     * Perform an Ethereum (EVM) transaction.
     * CallData may be inline if small, or in a "file" if large.
     */
    EthereumTransaction = 84;

    /**
     * Used to indicate when the network has updated the staking information at the end of
     * a staking period and to indicate a new staking period has started.
     */
    NodeStakeUpdate = 85;

    /**
     * Generate and return a pseudorandom number based on network state.
     */
    UtilPrng = 86;

    /**
     * Get a record for a "recent" transaction.
     */
    TransactionGetFastRecord = 87;

    /**
    * Update the metadata of one or more NFT's of a specific token type.
    */
    TokenUpdateNfts = 88;
}

/**
 * A set of values the nodes use in determining transaction and query fees, and constants involved
 * in fee calculations.  Nodes multiply the amount of "resources" allocated to a transaction or
 * query by the corresponding price to calculate the appropriate fee. Units are one-thousandth of a
 * tinyCent.  The "resource" allocations are estimated based on transaction characteristics and
 * current network state, and may be further adjusted based on network load and congestion.
 * <p>
 * This is used, in different contexts, for the cost _factors_ used to calculate charged amounts,
 * for the resource accumulation, and for actual amounts to be charged.
 */
message FeeComponents {
    /**
     * Minimum fee, the calculated fee must be greater than this value
     */
    int64 min = 1;

    /**
     * Maximum fee, the calculated fee must be less than this value
     */
    int64 max = 2;

    /**
     * Constant value.  A baseline constant contribution to total fee.
     */
    int64 constant = 3;

    /**
     * Bandwidth: "bytes per transaction".
     * The fee for bandwidth consumed by a transaction, measured in bytes
     */
    int64 bpt = 4;

    /**
     * Signatures: "validations per transaction".
     * The fee for signature verifications required by a transaction
     */
    int64 vpt = 5;

    /**
     * Memory: "RAM byte-hours"
     * The fee for RAM required to process a transaction, measured in byte-hours
     */
    int64 rbh = 6;

    /**
     * Disk: "storage byte-hours".
     * The fee for storage required by a transaction, measured in byte-hours
     */
    int64 sbh = 7;

    /**
     * Compute: Ethereum term for a derivative EVM compute resource.
     * The fee of computation for a smart contract transaction.  The value of gas is set by
     * a conversion rate, and is regularly updated to reflect reasonable and customary costs.
     */
    int64 gas = 8;

    /**
     * Ad valorem: "transferred value".
     * The fee for HBAR transferred by a transaction.
     */
    int64 tv = 9;

    /**
     * Response memory: "bytes per response"
     * The fee for data retrieved from memory to deliver a response, measured in bytes
     */
    int64 bpr = 10;

    /**
     * Response disk: "storage bytes per response"
     * The fee for data retrieved from disk to deliver a response, measured in bytes
     */
    int64 sbpr = 11;
}

/**
 * The fees for a specific transaction or query based on the fee data.
 */
message TransactionFeeSchedule {
    /**
     * The enumeration for a particular transaction or query.  The functionality type determines
     * the base cost parameters.
     */
    HederaFunctionality hederaFunctionality = 1;

    /**
     * Resource price coefficients.
     * Deprecated; use `fees` instead.
     */
    FeeData feeData = 2 [deprecated=true];

    /**
     * The resource price coefficients for transaction type and any applicable subtypes.
     * The multiple entries enable support for subtype price definitions.
     */
    repeated FeeData fees = 3;
}

/**
 * The total fee amounts charged for a transaction. Total fees are composed of three sets of
 * components.
 * <p>
 * - Node data, components that compensate the specific node that submitted the transaction.<br/>
 * - Network data, components that compensate the Hedera network for gossiping the transaction and
 *   determining the consensus timestamp.<br/>
 * - Service data, components that compensate the Hedera network for the ongoing maintenance
 *   and operation of the network, as well as ongoing development of network services.<br/>
 */
message FeeData {
    /**
     * Fee components to be paid to the submitting node.
     */
    FeeComponents nodedata = 1;

    /**
     * Fee components to be paid to the network for bringing a transaction to consensus.
     */
    FeeComponents networkdata = 2;

    /**
     * Fee components to be paid to the network for providing the immediate and ongoing services
     * associated with executing the transaction, maintaining the network, and developing the
     * network software.
     */
    FeeComponents servicedata = 3;

    /**
     * SubType distinguishing between different types of FeeData that may apply to the same
     * base transaction type (associated with an HederaFunctionality).
     */
    SubType subType = 4;
}

/**
 * A set of fee schedules covering all transaction types and query types, along with a specific
 * time at which this fee schedule will expire.
 * <p>
 * Nodes use the most recent unexpired fee schedule to determine the fees for all transactions
 * based on various resource components imputed to each transaction.
 */
message FeeSchedule {
    /**
     * Sets of price coefficients for various transaction or query types.
     */
    repeated TransactionFeeSchedule transactionFeeSchedule = 1;

    /**
     * The time, in seconds since the `epoch` when this fee schedule will expire.<br/>
     * For this purpose, `epoch` SHALL be the UNIX epoch with 0 at `1970-01-01T00:00:00.000Z`.
     */
    TimestampSeconds expiryTime = 2;
}

/**
 * The "current" fee schedule and the "next" fee schedule.
 * <p>
 * The current fee schedule is the schedule to apply to the current transaction.<br/>
 * The next fee schedule is the schedule that will apply after the current schedule expires.<br/>
 * We store both to avoid a condition where transactions are processed very near the time when a
 * fee schedule expires and it might be indeterminate which fees to apply.  With both current and
 * next fee schedule the network can deterministically apply the correct fee schedule based on
 * consensus timestamp for each transaction.
 */
message CurrentAndNextFeeSchedule {
    /**
     * Current unexpired fee schedule.
     */
    FeeSchedule currentFeeSchedule = 1;

    /**
     * Next fee schedule to use when current expires.
     */
    FeeSchedule nextFeeSchedule = 2;
}

/**
 * A network node endpoint.
 * Each network node in the global address book publishes one or more endpoints which enable the
 * nodes to communicate both with other nodes, for gossip, and with clients to receive transaction
 * requests.
 * The endpoint incorporates both IP address and port.
 * IPv6 is not currently supported.
 */
message ServiceEndpoint {
    /**
     * The 32-bit IPv4 address of the node encoded in pure "big-endian" (i.e. left to right) order
     * (e.g. `127.0.0.1` has hex bytes in the order `FF`, `00`, `00`, `01`).
     */
    bytes ipAddressV4 = 1;

    /**
     * The port value as a 32-bit integer between 0 and 65535, inclusive.
     */
    int32 port = 2;
}

/**
 * The data about a node, including its service endpoints and the Hedera account to be paid for
 * services provided by the node (that is, queries answered and transactions submitted.)
 * <p>
 * This legacy text is uncertain, the node should produce an error if current usage permits.
 * <blockquote>If the `serviceEndpoint` list is not set, or empty, then the endpoint given by the
 * `ipAddress` and `portno` fields MAY be used, but SHOULD produce an error message.</blockquote>
 * <p>
 * All active fields are populated in the 0.0.102 address book file.
 * Only fields documented with `0.0.101 field` are populated in the 0.0.101 address book file.
 */
message NodeAddress {
    /**
     * The IP address of the Node with separator & octets encoded in UTF-8.  Usage is deprecated,
     * ServiceEndpoint is now used to retrieve a node's list of IP addresses and ports, and this
     * value SHALL NOT be populated.
     */
    bytes ipAddress = 1 [deprecated=true];

    /**
     * The port number of the grpc server for the node.  Usage is deprecated, ServiceEndpoint is
     * now used to retrieve a node's list of IP addresses and ports and this value SHALL NOT be
     * populated.
     */
    int32 portno = 2 [deprecated=true];

    /**
     * Usage is deprecated, description provides short text functionality.
     * This field SHALL NOT be populated.
     */
    bytes memo = 3 [deprecated=true];

    /**
     * The X509 RSA _public_ key this node SHALL use to sign stream files (e.g., record stream
     * or block stream files). This field SHALL be a string of hexadecimal characters, encoded UTF-8,
     * which, translated to binary, form the public key DER encoding.
     */
    string RSA_PubKey = 4;

    /**
     * `0.0.101 field`
     * A numeric identifier for the node.  This value SHALL be non-sequential.
     */
    int64 nodeId = 5;

    /**
     * `0.0.101 field`
     * The account to be paid the "node" portion of transaction fees paid for queries and
     * transactions sent to this node.
     */
    AccountID nodeAccountId = 6;

    /**
     * `0.0.101 field`
     * A hash of the node's TLS certificate. This field is a string of UTF-8 encoded hexadecimal
     * characters which, translated to binary, are the SHA-384 hash of the UTF-8 NFKD encoding for
     * the node's TLS certificate in PEM format. Its value SHALL be used to verify the node TLS
     * certificate when presented during protocol negotiation.
     */
    bytes nodeCertHash = 7;

    /**
     * `0.0.101 field`
     * A node's service IP addresses and ports.  Nodes require multiple endpoints to ensure that
     * inter-node communication (e.g. gossip) is properly separated from client communication to
     * API endpoints.
     */
    repeated ServiceEndpoint serviceEndpoint = 8;

    /**
     * A short description of the node.
     * This value, if set, SHALL be encoded UTF-8 and SHALL NOT exceed 100 bytes when so encoded.
     */
    string description = 9;

    /**
     * [Deprecated] The amount of tinybar staked to the node.
     * This is replaced by per-account stake tracking and dynamic calculation.
     * This value SHOULD NOT be populated, and SHALL be ignored.
     */
    int64 stake = 10 [deprecated = true];
}

/**
 * A list of nodes and their metadata that contains details of the nodes running the network.  Used
 * to parse the contents of system files `0.0.101` and `0.0.102`.
 */
message NodeAddressBook {
    /**
     * Metadata of all nodes in the network
     */
    repeated NodeAddress nodeAddress = 1;
}

/**
 * Hedera follows semantic versioning (https://semver.org/) for both the HAPI protobufs and the
 * Services software.<br/>
 * Hedera modifies the "typical" semantic versioning somewhat, the `major` version is always `0`,
 * and each release increments the `minor` version.  The `patch` and `pre` components are used in
 * the typical manner.  The `build` component is not generally used.
 */
message SemanticVersion {
    /**
     * Increases with incompatible API changes.
     * Hedera does not increment this value and retains a `0` value to indicate that API may
     * change for any release.
     */
    int32 major = 1;

    /**
     * Increases with backwards-compatible new functionality.
     * Hedera increments this value with each release.  There may be incompatible API changes.
     */
    int32 minor = 2;

    /**
     * Increases with backwards-compatible bug fixes.
     */
    int32 patch = 3;

    /**
     * A pre-release version MAY be denoted by appending a hyphen and a series of dot separated
     * identifiers (https://semver.org/#spec-item-9); so given a semver 0.14.0-alpha.1+21AF26D3,
     * this field would contain 'alpha.1'
     */
    string pre = 4;

    /**
     * Build metadata MAY be denoted by appending a plus sign and a series of dot separated
     * identifiers immediately following the patch or pre-release version
     * (https://semver.org/#spec-item-10); so given a semver 0.14.0-alpha.1+21AF26D3, this field
     * would contain '21AF26D3'
     */
    string build = 5;
}

/**
 * A single runtime configuration setting.  Typically a name-value pair, this may also contain
 * a small amount of ancillary data.
 */
message Setting {
    /**
     * The name of this setting property.
     */
    string name = 1;

    /**
     * The value of this setting property.
     */
    string value = 2;

    /**
     * A small quantity of data associated with this setting.  This SHOULD be less than 100 bytes.
     * If the value is a string, it MUST be encoded UTF-8.
     */
    bytes data = 3;
}

/**
 * Setting values representing a source of runtime configuration information.
 */
message ServicesConfigurationList {
    /**
     * A List of `Setting`s, typically read from the application properties.
     */
    repeated Setting nameValue = 1;
}

/**
 * An Hedera Token Service token relationship.  A token relationship describes the connection
 * between an Account and a Token type, including the current account balance in that token.
 * <p>
 * A TokenRelationship SHALL contain, for the referenced token and enclosing account,<br/>
 * The account's current balance, whether the account has KYC granted, whether the assets are frozen
 * and whether the association was automatic.<br/>
 * A TokenRelationship MAY also contain the `symbol` and `decimals` values copied from the token.
 * <p>
 * TokenRelationship entries are only valid within the context of a `GetAccountDetails` query
 * response, which specifies the account side of the relationship.
 */
message TokenRelationship {
    /**
     * The ID of the token
     */
    TokenID tokenId = 1;

    /**
     * The Symbol of the token
     */
    string symbol = 2;

    /**
     * For fungible (non-unique) tokens this is the balance that the Account holds of that token.
     * The value is provided as an integer amount of the smallest unit of the token
     * (i.e. 10<sup>`-decimals`</sup> whole tokens).
     * <p>
     * For non-fungible (unique) tokens this is the whole number of unique tokens held by the
     * account for this token type.
     */
    uint64 balance = 3;

    /**
     * The KYC status of the account (`KycNotApplicable`, `Granted` or `Revoked`) with respect to
     * this token.  If KYC is not supported for this token (e.g. the `kyc_key` of the token
     * is not set), this will be `KycNotApplicable`.
     */
    TokenKycStatus kycStatus = 4;

    /**
     * The Freeze status of the account (FreezeNotApplicable, Frozen or Unfrozen) with respect to
     * this token. If the token cannot freeze account assets (e.g. the `freeze_key` of the token
     * is not set), this will be `FreezeNotApplicable`.
     */
    TokenFreezeStatus freezeStatus = 5;

    /**
     * The maximum "precision" for this token.  A single whole token may be divided into at most
     * 10<sup>`decimals`</sup> sub-units.
     */
    uint32 decimals = 6;

    /**
     * Describes whether the relationship was created implicitly (automatically) or
     * explicitly (manually) via a `TokenAssociate` transaction.
     */
    bool automatic_association = 7;
}

/**
 * A number of _transferable units_ of a specified token.
 * <p>
 * The transferable unit of a token is its smallest denomination, as given by the token's
 * `decimals` property. Each minted token contains 10<sup>`decimals`</sup> transferable units.
 * For example, we could think of the cent as the transferable unit of the US
 * dollar (`decimals=2`); and the tinybar as the transferable unit of HBAR (`decimals=8`).
 * <p>
 * Transferable units are not directly comparable across different tokens.
 */
message TokenBalance {
    /**
     * The unique token ID for the token to be described.
     */
    TokenID tokenId = 1;

    /**
     * The number of transferable units of the identified token.<br/>
     * For fungible (non-unique) tokens this is the balance, in units of 10<sup>`-decimals`</sup>
     * whole tokens.<br/>
     * For non-fungible (unique) tokens, this is the number of individual unique tokens in
     * this balance.
     */
    uint64 balance = 2;

    /**
     * Tokens divide into 10<sup>`decimals`</sup> sub-units.
     */
    uint32 decimals = 3;
}

/**
 * A set of token balance values.  Each entry describes the balance the enclosing account holds for
 * a specific token.  The balance is an amount for a fungible (non-unique) token or a count for a
 * non-fungible (unique) token.
 */
message TokenBalances {
    /**
     * A list of token balance values, each represents a single account balance for a single token.
     */
    repeated TokenBalance tokenBalances = 1;
}

/**
 * An association between a token and an account.  An account must be associated with a token before
 * that account can transact (send or receive) that token.
 */
message TokenAssociation {
    /**
     * The ID value for the token associated.
     */
    TokenID token_id = 1;

    /**
     * The ID value for the associated account.
     */
    AccountID account_id = 2;
}

/**
 * Staking metadata (info) for an account or a contract.
 * This is used for responses returned from CryptoGetInfo or ContractGetInfo queries.
 */
message StakingInfo {

    /**
     * A flag indicating if the holder of this account has chosen to decline staking rewards.
     */
    bool decline_reward = 1;

    /**
     * A `Timestamp` indicating the start time of the most recent staking period during which either
     * the staking settings for this account or contract changed or the account or contract
     * received staking rewards, whichever is later.  Examples of a change in staking settings
     * include starting staking or changing the staked_node_id.<br/>
     * If this account or contract is not currently staked to a node, then this field SHALL NOT be
     * set.
     */
    Timestamp stake_period_start = 2;

    /**
     * The amount in tinybars that will be received in the next reward payout.  Rewards are not
     * paid out immediately; for efficiency reasons rewards are only paid out as part of some other
     * transaction involving that account.
     */
    int64 pending_reward = 3;

    /**
     * The total HBAR balance of all accounts proxy-staked to this account or contract.
     */
    int64 staked_to_me = 4;

    /**
     * An ID for the account or node to which this account or contract is staking.
     */
    oneof staked_id {

        /**
         * The account to which this account or contract is staking.
         */
        AccountID staked_account_id = 5;

        /**
         * The node to which this account or contract is staking.
         */
        int64 staked_node_id = 6;
    }
}
